#ifndef ROUTING_H
#define ROUTING_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#if defined(__GNUC__) && (__GNUC__ >= 4)
#define RT_MUST_USE __attribute__ ((warn_unused_result))
#elif defined(_MSC_VER) && (_MSC_VER >= 1700)
#define RT_MUST_USE _Check_return_
#else
#define RT_MUST_USE
#endif

/**
 * Indicates no associated bounding box.
 */
#define RT_INVALID_BOUNDING_BOX_INDEX (-1)

/**
 * Indicates no associated node.
 */
#define RT_INVALID_NODE_INDEX (-1)

enum RT_Directions {
    RT_DIRECTIONS_POS_X = 1,
    RT_DIRECTIONS_NEG_X = 2,
    RT_DIRECTIONS_POS_Y = 4,
    RT_DIRECTIONS_NEG_Y = 8,
    RT_DIRECTIONS_X = 3,
    RT_DIRECTIONS_Y = 12,
    RT_DIRECTIONS_NONE = 0,
    RT_DIRECTIONS_ALL = 15,
};
typedef uint8_t RT_Directions;

enum RT_Result {
    RT_RESULT_SUCCESS = 0,
    RT_RESULT_NULL_POINTER_ERROR = 1,
    RT_RESULT_INVALID_OPERATION_ERROR = 2,
    RT_RESULT_BUFFER_OVERFLOW_ERROR = 3,
    RT_RESULT_UNINITIALIZED_ERROR = 4,
};
typedef uint32_t RT_Result;

typedef struct RT_Graph RT_Graph;

typedef struct RT_Point {
    /**
     * The X coordinate of the point.
     */
    int32_t x;
    /**
     * The Y coordinate of the point.
     */
    int32_t y;
} RT_Point;

typedef uint32_t RT_BoundingBoxIndex;

typedef struct RT_Anchor {
    /**
     * The position of the anchor.
     */
    struct RT_Point position;
    /**
     * The bounding box this anchor belongs to, or `RT_INVALID_BOUNDING_BOX_INDEX` if none.
     */
    RT_BoundingBoxIndex bounding_box;
    /**
     * The directions in which this anchor connects.
     */
    RT_Directions connect_directions;
} RT_Anchor;

typedef struct RT_BoundingBox {
    /**
     * The center of the bounding box.
     */
    struct RT_Point center;
    /**
     * The distance from the center to the left and right of the bounding box.
     */
    uint16_t half_width;
    /**
     * The distance from the center to the top and bottom of the bounding box.
     */
    uint16_t half_height;
} RT_BoundingBox;

typedef uint32_t RT_NodeIndex;

typedef struct RT_NeighborList {
    /**
     * The neighbor in the positive X direction, or `RT_INVALID_NODE_INDEX` if none.
     */
    RT_NodeIndex pos_x;
    /**
     * The neighbor in the negative X direction, or `RT_INVALID_NODE_INDEX` if none.
     */
    RT_NodeIndex neg_x;
    /**
     * The neighbor in the positive Y direction, or `RT_INVALID_NODE_INDEX` if none.
     */
    RT_NodeIndex pos_y;
    /**
     * The neighbor in the negative Y direction, or `RT_INVALID_NODE_INDEX` if none.
     */
    RT_NodeIndex neg_y;
} RT_NeighborList;

typedef struct RT_Node {
    /**
     * The position of the node.
     */
    struct RT_Point position;
    /**
     * The neighbors of the node.
     */
    struct RT_NeighborList neighbors;
} RT_Node;

typedef struct RT_PathDef {
    /**
     * The start point of the path.
     */
    struct RT_Point start;
    /**
     * The end point of the path.
     */
    struct RT_Point end;
} RT_PathDef;

typedef struct RT_PathRange {
    /**
     * The vertex offset this range starts at.
     */
    uint32_t vertex_offset;
    /**
     * The length of this range.
     */
    uint16_t vertex_count;
    /**
     * The index of the vertex buffer this range is in.
     */
    uint16_t vertex_buffer_index;
} RT_PathRange;

typedef struct RT_Vertex {
    /**
     * The X coordinate of the vertex.
     */
    float x;
    /**
     * The Y coordinate of the vertex.
     */
    float y;
} RT_Vertex;

typedef struct RT_VertexBuffer {
    /**
     * A list of vertices.
     */
    struct RT_Vertex *vertices;
    /**
     * The number of elements in `vertices`.
     */
    uint32_t vertex_count;
} RT_VertexBuffer;

/**
 * Initializes the thread pool.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_INVALID_OPERATION_ERROR`: The function was called more than once.
 */
RT_MUST_USE RT_Result RT_init_thread_pool(void);

/**
 * Gets the number of threads in the pool.
 *
 * **Parameters**
 * `[out] thread_count`: The number of threads in the pool.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `thread_count` was `NULL`.
 * `RT_RESULT_UNINITIALIZED_ERROR`: The thread pool was not initialized yet.
 */
RT_MUST_USE RT_Result RT_get_thread_count(uint16_t *thread_count);

/**
 * Creates a new graph.
 *
 * **Parameters**
 * `[out] graph`: The created graph.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `graph` was `NULL`.
 */
RT_MUST_USE RT_Result RT_graph_new(struct RT_Graph **graph);

/**
 * Builds a graph.
 *
 * **Parameters**
 * `graph`: The graph to build.
 * `anchors`: A list of anchor points to build the graph from.
 * `anchor_count`: The number of elements in `anchors`.
 * `bounding_boxes`: A list of bounding boxes to build the graph from.
 * `bounding_box_count`: The number of elements in `bounding_boxes`.
 * `minimal`: Whether to spend more processing time to ensure the graph is minimal.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `graph`, `anchor_points` or `bounding_boxes` was `NULL`.
 */
RT_MUST_USE
RT_Result RT_graph_build(struct RT_Graph *graph,
                         const struct RT_Anchor *anchors,
                         size_t anchor_count,
                         const struct RT_BoundingBox *bounding_boxes,
                         size_t bounding_box_count,
                         bool minimal);

/**
 * Gets the nodes in a graph.
 *
 * **Parameters**
 * `graph`: The graph to get the nodes of.
 * `[out] nodes`: The list of nodes in the graph.
 * `[out] node_count`: The number of elements in `nodes`.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `graph`, `nodes` or `node_count` was `NULL`.
 */
RT_MUST_USE
RT_Result RT_graph_get_nodes(const struct RT_Graph *graph,
                             const struct RT_Node **nodes,
                             size_t *node_count);

/**
 * Frees a graph.
 *
 * **Parameters**
 * `graph`: The graph to free.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `graph` was `NULL`.
 */
RT_MUST_USE RT_Result RT_graph_free(struct RT_Graph *graph);

/**
 * Finds shortest paths through a graph.
 *
 * **Parameters**
 * `graph`: The graph to find the paths through.
 * `paths`: A list of paths to find.
 * `path_ranges`: A list to write the range of vertices that belongs to each path into.
 * `path_count`: The number of elements in `paths` and `path_ranges`.
 * `vertex_buffers`: A list of buffers to write the found paths into. There must be exactly as many buffers as threads in the pool.
 * `vertex_buffer_capacity`: The maximum number of vertices each buffer in `vertex_buffers` can hold.
 *
 * **Returns**
 * `RT_RESULT_SUCCESS`: The operation completed successfully.
 * `RT_RESULT_NULL_POINTER_ERROR`: `graph`, `paths`, `path_ranges`, `vertex_buffers` or `VertexBuffer::vertices` was `NULL`.
 * `RT_RESULT_INVALID_OPERATION_ERROR`: One of the paths had an invalid start or end point.
 * `RT_RESULT_BUFFER_OVERFLOW_ERROR`: The capacity of the vertex buffers was too small to hold all vertices.
 * `RT_RESULT_UNINITIALIZED_ERROR`: The thread pool was not initialized yet.
 */
RT_MUST_USE
RT_Result RT_graph_find_paths(const struct RT_Graph *graph,
                              const struct RT_PathDef *paths,
                              struct RT_PathRange *path_ranges,
                              uint32_t path_count,
                              struct RT_VertexBuffer *vertex_buffers,
                              uint32_t vertex_buffer_capacity);

#endif /* ROUTING_H */
